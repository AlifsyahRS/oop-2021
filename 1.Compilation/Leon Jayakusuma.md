## Java Compilation Process
#### by Leon Jayakusuma

  In Java, the compilation process is a little bit different compared to other programming languages. The difference is how the Java source code is not interpreted or even compiled directly, rather Java source code is compiled into bytecode first. After the source code has been converted successfully into bytecode, the bytecode is then processed again by Java interpreter called a Java Virtual Machine (JVM) into machine code (binary code) that the CPU can directly understand. The bytecode is understood by most platforms and most programming languages, so it only has one representation. Another important difference is that Java uses both compilation and interpretation in its execution process.
## Steps
### 1. Conversion of Source Code to Bytecode --> Compile Time
  Java source code is converted by the Java compiler ([javac](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html#synopsis)) into bytecode. [Java Development Kit](https://www.oracle.com/java/technologies/javase-downloads.html), which can be downloaded through the official Oracle website, is basically Java Runtime Environment(JRE) with [javac](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html#synopsis).  The resulting language is a lower level language that is difficult to be read by human but still comprehensible if you try hard enough. This bytecode is to be passed to the Java Virtual Machine later for further processing. This process only need to happen once (the initial compilation), afterwards, bytecode is there to run again without having to repeat the compilation process, except if you make any changes to your program. 
  One thing to note is that compilation (conversion of source code to byte code) happens before any piece of source code is run. This makes the build process (initially) a bit slower than an interpreted language, but for an end user application, this will greatly speed up the performance compared to interpreted language (e.g. Python), as the app source code that you have written don't have to be recompiled, drastically improving loading time. However, compared to lower-level programming language (C / C++) that can be directly converted to machine code, this process is a bit slower. But the advantage to this process is that the code that you write in Java are platform-independent, that means you only need to write a code once and it can be run on any platform, as long as they have a virtual machine interpreter. The Java source code is saved in a file with the .java extension. 
  The compilation process can be summarized with these [steps](https://www.geeksforgeeks.org/compilation-execution-java-program/):
  1. Parsing : create a tree-representation (Abstract Syntax Tree) of the source code
  2. Symbol Table : create a symbol table from the identifiers found in AST that has been created for further processing 
  3. Annotation Processing : processes annotation(comment-like entity that can also behave as a preprocessor for some keywords)
  4. Attribute : attributes the AST, includes name resolution(same identifier with same position in different scope), type checking, and [constant folding and propagation](https://en.wikipedia.org/wiki/Constant_folding)(in some cases also uses dead code elimination. Constant folding is the process whereby mathematical expressions with constants are evaluated at compile-time. Whereas constant propagation is substituting variables with constants. Dead code elimination are removal of code that doesn't affect execution of program if removed (usually happens after constant folding and propagation). 
  5. Flow : Data flow analysis on trees
### 2. Conversion of Byte Code to Machine Code
  After the Java source code has been converted to bytecode, the bytecode is then passed to JVM. The JVM then interprets the bytecode into their respective platform-specific machine code, as each platform has their own encoding scheme when running machine code or binary code. JVM is called a virtual machine because essentially, it means that it is an emulator for a machine platform. So, JVM is a machine like any other, but it runs on top of the other platforms. The bytecode is usually saved with the .class or .jar (java archive) extension But many people are confused, why do we convert it into a bytecode first, then interpret it with platform-specific JVM ? Citing one of the [answers](https://softwareengineering.stackexchange.com/questions/345458/what-is-the-use-of-converting-source-code-to-java-bytecode) in the software engineering stackexchange forum that I've linked below, think of the example below:
  As mentioned before, the bytecode's format is agreed upon by most platform and most programming language. Suppose we have M programming languages and N platforms and each compiler needs to be platform-specific and language-specific, this means we need approximately M*N compilers. Meanwhile, bytecodes are platform-independent. This means, we can have M 'front-end' compilers that translates the language into bytecodes and N 'back-end' compilers that translates the bytecode into machine code, in total M+N compilers.
  Another advantage of compiling into bytecode first is that the problem of the compilation process can be divided into two parts which is parsing the language(mostly) and some other stuff, and the other part is back-end stuff like processor design, instruction set, etc.
  
  source : 
  http://www2.hawaii.edu/~takebaya/ics111/process_of_programming/process_of_programming.html
  https://en.wikibooks.org/wiki/Java_Programming/Compilation
  https://softwareengineering.stackexchange.com/questions/345458/what-is-the-use-of-converting-source-code-to-java-bytecode
  https://www.geeksforgeeks.org/compilation-execution-java-program/
  https://www.geeksforgeeks.org/jvm-works-jvm-architecture/
  https://en.wikipedia.org/wiki/Constant_folding
  
